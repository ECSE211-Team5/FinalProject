.TH "ca.mcgill.ecse211.project.Navigation" 3 "Wed Nov 28 2018" "Version 1.0" "ECSE211 - Fall 2018 - Final Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ca.mcgill.ecse211.project.Navigation
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNavigation\fP (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor)  throws OdometerExceptions "
.br
.ti -1c
.RI "void \fBsetSlowAcc\fP ()"
.br
.ti -1c
.RI "double \fBcalculateAngleTo\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBtravelTo\fP (double x, double y, int speed)"
.br
.ti -1c
.RI "void \fBtravelToWithCorrection\fP (int x, int y, boolean avoid)"
.br
.ti -1c
.RI "synchronized void \fBmoveWithCorrection\fP (double distance, double theta)"
.br
.ti -1c
.RI "void \fBmoveOneTileWithCorrection\fP (double theta)"
.br
.ti -1c
.RI "synchronized void \fBturnTo\fP (double angle)"
.br
.ti -1c
.RI "void \fBgoThroughTunnel\fP ()  throws Exception "
.br
.ti -1c
.RI "void \fBsearchRingSet\fP (\fBRingSearcher\fP searcher, boolean correct, boolean reset)"
.br
.ti -1c
.RI "void \fBturn\fP (int angle)"
.br
.ti -1c
.RI "void \fBforward\fP (int speed, double distance)"
.br
.ti -1c
.RI "void \fBstop\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBconvertDistance\fP (double radius, double distance)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Navigator class extends the functionality of the \fBNavigation\fP class\&. It offers an alternative \fBtravelTo()\fP method which uses a state machine to implement obstacle avoidance\&.
.PP
The Navigator class does not override any of the methods in \fBNavigation\fP\&. All methods with the same name are overloaded i\&.e\&. the Navigator version takes different parameters than the \fBNavigation\fP version\&.
.PP
This is useful if, for instance, you want to force travel without obstacle detection over small distances\&. One place where you might want to do this is in the ObstacleAvoidance class\&. Another place is methods that implement specific features for future milestones such as retrieving an object\&.
.PP
\fBAuthor:\fP
.RS 4
Caspar Cedro 
.PP
Percy Chen 
.PP
Patrick Erath 
.PP
Anssam Ghezala 
.PP
Susan Matuszewski 
.PP
Kamy Moussavi Kafi 
.RE
.PP

.PP
Definition at line 30 of file Navigation\&.java\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.Navigation (EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor) throws \fBOdometerExceptions\fP"
This navigation class constructor sets up our robot to begin navigating a particular map
.PP
\fBParameters:\fP
.RS 4
\fIleftMotor\fP The EV3LargeRegulatedMotor instance for our left motor 
.br
\fIrightMotor\fP The EV3LargeRegulatedMotor instance for our right motor 
.RE
.PP

.PP
Definition at line 61 of file Navigation\&.java\&.
.PP
.nf
62                                 {
63     this\&.odometer = Odometer\&.getOdometer();
64     this\&.leftMotor = leftMotor;
65     this\&.rightMotor = rightMotor;
66     this\&.data = SensorData\&.getSensorData();
67     for (EV3LargeRegulatedMotor motor : new EV3LargeRegulatedMotor[] {this\&.leftMotor,
68         this\&.rightMotor}) {
69       motor\&.stop();
70       motor\&.setAcceleration(Q_ACCELERATION);
71     }
72   }
.fi
.SH "Member Function Documentation"
.PP 
.SS "double ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.calculateAngleTo (double x, double y)"
This method calculate the angle for the robot to rotate facing certain point
.PP
\fBParameters:\fP
.RS 4
\fIx\fP x coordinate of the point 
.br
\fIy\fP y coordinate of the point 
.RE
.PP
\fBReturns:\fP
.RS 4
: rotation needed in degree 
.RE
.PP

.PP
Definition at line 85 of file Navigation\&.java\&.
.PP
.nf
85                                                      {
86     double dX = x - odometer\&.getXYT()[0];
87     double dY = y - odometer\&.getXYT()[1];
88     double theta = Math\&.atan(dX / dY);
89     if (dY < 0 && theta < Math\&.PI)
90       theta += Math\&.PI;
91     return theta;
92   }
.fi
.SS "static int ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.convertDistance (double radius, double distance)\fC [static]\fP"
This method allows the conversion of a distance to the total rotation of each wheel need to cover that distance\&.
.PP
\fBParameters:\fP
.RS 4
\fIradius\fP The radius of our wheels 
.br
\fIdistance\fP The distance traveled 
.RE
.PP
\fBReturns:\fP
.RS 4
A converted distance 
.RE
.PP

.PP
Definition at line 658 of file Navigation\&.java\&.
.PP
.nf
658                                                                     {
659     return (int) ((180\&.0 * distance) / (Math\&.PI * radius));
660   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.forward (int speed, double distance)"
Move the robot forward
.PP
\fBParameters:\fP
.RS 4
\fIspeed\fP speed to be taken 
.br
\fIdistance\fP distacne to travel 
.RE
.PP

.PP
Definition at line 629 of file Navigation\&.java\&.
.PP
.nf
629                                                   {
630     leftMotor\&.setSpeed(speed);
631     rightMotor\&.setSpeed(speed);
632     try {
633       Thread\&.sleep(100);
634     } catch (InterruptedException e) {
635       // TODO Auto-generated catch block
636       e\&.printStackTrace();
637     }
638     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
639     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
640   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.goThroughTunnel () throws Exception"
found the tunnel based on the ll and ur coordinate, after the method, the robot will go the the entrance of the tunnel facing the tunnel it returns the distance it needs to go for [x] and [y] in order to go through the tunnel
.PP
\fBExceptions:\fP
.RS 4
\fIException\fP 
.RE
.PP

.PP
Definition at line 397 of file Navigation\&.java\&.
.PP
.nf
397                                                  {
398     int distance = 0;
399     int[] ll, ur;
400     // first use ll and ur coordinate to calculate lr and ul of the tunnel
401     ll = GameParameters\&.TN_LL;
402     ur = GameParameters\&.TN_UR;
403     int[] lr = {ll[0], ur[1]};
404     int[] ul = {ur[0], ll[1]};
405 
406     // clone the four points (to make sure we are not modifying the original one)
407     int[][] corners = {ll\&.clone(), lr\&.clone(), ul\&.clone(), ur\&.clone()};
408     ArrayList<int[]> notIn = new ArrayList<int[]>();
409     ArrayList<int[]> points = new ArrayList<int[]>();
410     double[] position = odometer\&.getXYT();
411 
412     // search for the points that are the same as the current area of the robot
413     // these are the entrance of the tunnel, also find the other two points, those
414     // are the exit of the tunnel
415     GameParameters\&.AreaType type =
416         GameParameters\&.getType((int) Math\&.round(position[0]), (int) Math\&.round(position[1]));
417     for (int[] point : corners) {
418       if (GameParameters\&.getType(point[0], point[1]) == type) {
419         points\&.add(point);
420       } else {
421         notIn\&.add(point);
422       }
423     }
424 
425     // Sort the two point at exit by the distance to the destination
426     if (type == GameParameters\&.AreaType\&.InStarting) {
427       Collections\&.sort(notIn, new GameUtil\&.RingSetComparator());
428     } else if (type == GameParameters\&.AreaType\&.Searching) {
429       Collections\&.sort(notIn, new GameUtil\&.StartingComparator());
430     }
431 
432     // find the direction and length of the tunnel
433     // we know the entrance two points of the tunnel, so this means
434     // the two points must have either x or y coordinate identical\&.
435     // that's the direction of the tunnel as well
436     // after identify it's direction, we find whether it is positive
437     // or negative directed
438     if (points\&.get(0)[0] == points\&.get(1)[0]) {
439       distance = Math\&.abs(notIn\&.get(0)[0] - points\&.get(0)[0]);
440       int multi = notIn\&.get(0)[0] - points\&.get(0)[0] < 0 ? 1 : -1;
441       travelToTunnelEntrance(points, 0, multi);
442       for (int i = 0; i < notIn\&.size(); i++) {
443         // this step is to find the nearest two points that we can go two
444         // after exit the tunnel
445         notIn\&.get(i)[0] = notIn\&.get(i)[0] - multi * 1;
446       }
447     } else {
448       distance = Math\&.abs(notIn\&.get(0)[1] - points\&.get(0)[1]);
449       int multi = notIn\&.get(0)[1] - points\&.get(0)[1] < 0 ? 1 : -1;
450       travelToTunnelEntrance(points, 1, multi);
451       for (int i = 0; i < notIn\&.size(); i++) {
452         // this step is to find the nearest two points that we can go two
453         // after exit the tunnel
454         notIn\&.get(i)[1] = notIn\&.get(i)[1] - multi * 1;
455       }
456     }
457 
458     double[] tunnelEnd = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
459     double angleThoughTunnel = Math\&.toDegrees(calculateAngleTo(tunnelEnd[0], tunnelEnd[1]));
460     turnTo(angleThoughTunnel);
461 
462     // goback To correct
463       moveBackWithCorrection();
464 
465     // turn left -5 to correct the effect of the weight
466     forward(TUNNEL_SPEED, 0\&.5);
467     turn(TUNNEL_CORRECTION);
468     if (distance == 1) {
469       forward(TUNNEL_SPEED, distance + 1 );
470     } else {
471 
472       forward(TUNNEL_SPEED, distance + 1 );
473     }
474 
475     odometer\&.setTheta(angleThoughTunnel);
476     // leftMotor\&.setAcceleration(N_ACCELERATION);
477     // rightMotor\&.setAcceleration(N_ACCELERATION);
478     // // rotate additional sensor distances to make sure the sensor will not on the balck line
479     // leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), true);
480     // rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, 2*Game\&.SEN_DIS), false);
481     this\&.moveOneTileWithCorrection(angleThoughTunnel);
482     double[] after = GameUtil\&.average(notIn\&.get(0), notIn\&.get(1));
483     odometer\&.setX(after[0]);
484     odometer\&.setY(after[1]);
485     // go to the nearest safe point near tunnel
486     for (int[] p : notIn) {
487       if (GameUtil\&.isSafe(p)) {
488         double toPointAngle = Math\&.toDegrees(calculateAngleTo(p[0], p[1]));
489         turnTo(toPointAngle);
490         this\&.moveOneTileWithCorrection(toPointAngle);
491         odometer\&.setX(p[0]);
492         odometer\&.setY(p[1]);
493         break;
494       }
495     }
496   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveOneTileWithCorrection (double theta)"
This method move the robot one tile until it detect a blackline (ususally one tile)
.PP
\fBParameters:\fP
.RS 4
\fItheta\fP 
.RE
.PP

.PP
Definition at line 257 of file Navigation\&.java\&.
.PP
.nf
257                                                       {
258     // leftMotor\&.setAcceleration(N_ACCELERATION);
259     // rightMotor\&.setAcceleration(N_ACCELERATION);
260     leftMotor\&.setSpeed(FORWARD_SPEED);
261     rightMotor\&.setSpeed(FORWARD_SPEED);
262     leftMotor\&.forward();
263     rightMotor\&.forward();
264     moveUntilLineDetection(true);
265     odometer\&.setTheta(theta);
266   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.moveWithCorrection (double distance, double theta)"
Move a certain distance with correction along current direction (using coordinate system)
.PP
\fBParameters:\fP
.RS 4
\fIdistance\fP distance to cover 
.br
\fItheta\fP theta to be corrected each time 
.RE
.PP

.PP
Definition at line 228 of file Navigation\&.java\&.
.PP
.nf
228                                                                              {
229     leftMotor\&.setSpeed(FORWARD_SPEED);
230     rightMotor\&.setSpeed(FORWARD_SPEED);
231 
232     // correct error of the distance
233     int tiles = Math\&.abs((int) Math\&.round(distance));
234     for (int i = 0; i < tiles; i++) {
235       moveOneTileWithCorrection(theta);
236     }
237   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.searchRingSet (\fBRingSearcher\fP searcher, boolean correct, boolean reset)"

.IP "\(bu" 2
this method approaches the ring set by paying attention to the reading of us sensor, stops at the place when the robot can reach the ring
.PP
.PP
\fBParameters:\fP
.RS 4
\fIsearcher\fP ring searcher 
.br
\fIcorrect\fP whether correct the position when searching ring (cannot do this when at boundary) 
.br
\fIreset\fP whether reset the rod motor to the original position 
.RE
.PP

.PP
Definition at line 540 of file Navigation\&.java\&.
.PP
.nf
540                                                                                    {
541     // Go backward to detect the line and correct the rotation
542     // leftMotor\&.setAcceleration(N_ACCELERATION);
543     // rightMotor\&.setAcceleration(N_ACCELERATION);
544     leftMotor\&.setSpeed(FORWARD_SPEED);
545     rightMotor\&.setSpeed(FORWARD_SPEED);
546     try {
547       Thread\&.sleep(100);
548     } catch (InterruptedException e) {
549       // TODO Auto-generated catch block
550       e\&.printStackTrace();
551     }
552     double theta = odometer\&.getXYT()[2];
553 
554     // if we do correction, we need to forward more (for the sensor distance)
555     if (correct) {
556       leftMotor\&.backward();
557       rightMotor\&.backward();
558       moveUntilLineDetection(true);
559       // Forward for 3 cm (approach the ring set)
560       //forward(FORWARD_SPEED, 2\&.5 / Game\&.TILE);
561     } else {
562       //forward(FORWARD_SPEED, 2 / Game\&.TILE);
563     }
564     searcher\&.prepareRetrieve();
565     // rotate a little to the left to make sure that the sensor can detect the ring
566     // detect the ring color and beep based on the color
567     searcher\&.search(-165);
568     if(correct) {
569       forward(FORWARD_SPEED, 2\&.8 / Game\&.TILE);
570     }else {
571       forward(FORWARD_SPEED, 3\&.8 / Game\&.TILE);
572     }
573     searcher\&.detectColor();
574     searcher\&.search(-190);
575     searcher\&.detectColor();
576     
577     // rotate back
578    // leftMotor\&.rotate(-LEFT_MOTOR_RING_COR, false);
579     // prepare for retrieving the ring
580     searcher\&.finishSearch();
581     
582     rightMotor\&.rotate(-40, false);
583     searcher\&.safeRod();
584     if(correct) {
585       forward(FORWARD_SPEED, 3\&.7 / Game\&.TILE);
586     }else {
587       forward(FORWARD_SPEED, 2\&.7 / Game\&.TILE);
588     }
589     // go back to original position
590     rightMotor\&.rotate(70, false);
591     searcher\&.retrieveRing();
592     // rotate the right motor to behind a little to make sure we can put the rod behind the ring
593     //rightMotor\&.rotate(RIGHT_MOTOR_RING_COR, false);
594 
595     // go to the position where ring can be retrieved
596 
597     // rotate a little to the left to make sure not influence the other ring
598     rightMotor\&.rotate(-70, false);
599 
600     forward(FORWARD_SPEED, -6\&.5 / Game\&.TILE);
601     // go back to original position
602     rightMotor\&.rotate(40+30, false);
603 
604 //    if (correct) {
605 //      forward(FORWARD_SPEED, -6\&.5 / Game\&.TILE);
606 //    } else {
607 //      forward(FORWARD_SPEED, -6 / Game\&.TILE);
608 //    }
609     //if (reset)
610       //searcher\&.resetRodMotor();
611   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.setSlowAcc ()"

.PP
Definition at line 74 of file Navigation\&.java\&.
.PP
.nf
74                            {
75     leftMotor\&.setAcceleration(N_ACCELERATION);
76     rightMotor\&.setAcceleration(N_ACCELERATION);
77   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.stop ()"
Stop the motor 
.PP
Definition at line 645 of file Navigation\&.java\&.
.PP
.nf
645                      {
646     leftMotor\&.stop(true);
647     rightMotor\&.stop(false);
648   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelTo (double x, double y, int speed)"
Travel to a point naively: by rotating the robot facing the point first and then go to the point
.PP
\fBParameters:\fP
.RS 4
\fIx\fP x coordinate of the point 
.br
\fIy\fP y coordinate of the points 
.RE
.PP

.PP
Definition at line 101 of file Navigation\&.java\&.
.PP
.nf
101                                                       {
102     double dX = x - odometer\&.getXYT()[0];
103     double dY = y - odometer\&.getXYT()[1];
104     double theta = calculateAngleTo(x, y);
105 
106     // Euclidean distance calculation\&.
107     double distance = Math\&.sqrt(Math\&.pow(dX, 2) + Math\&.pow(dY, 2));
108 
109     turnTo(Math\&.toDegrees(theta));
110     leftMotor\&.setSpeed(speed);
111     rightMotor\&.setSpeed(speed);
112     try {
113       Thread\&.sleep(100);
114     } catch (InterruptedException e) {
115       // TODO Auto-generated catch block
116       e\&.printStackTrace();
117     }
118    
119 
120     leftMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), true);
121     rightMotor\&.rotate(convertDistance(Game\&.WHEEL_RAD, distance * Game\&.TILE), false);
122     
123   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.travelToWithCorrection (int x, int y, boolean avoid)"
This method travel the robot to desired position by following the line (Always rotate 90 degree), along with a correction
.PP
When avoid=true, the nav thread will handle traveling\&. If you want to travel without avoidance, this is also possible\&. In this case, the method in the \fBNavigation\fP class is used\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP The x coordinate to travel to (in cm) 
.br
\fIy\fP The y coordinate to travel to (in cm) 
.br
\fIavoid\fP the robot will pay attention to the distance from ultrasonic sensor to avoid abstacle when navigating 
.RE
.PP

.PP
Definition at line 137 of file Navigation\&.java\&.
.PP
.nf
137                                                                   {
138     int px = (int) Math\&.round(odometer\&.getXYT()[0]);
139     int py = (int) Math\&.round(odometer\&.getXYT()[1]);
140     int[] cur = {px, py};
141     int[] destination = {x, y};
142     ArrayList<Character> instruction = new ArrayList<Character>();
143 
144     // use path finder to find path based on different area the robot is at
145     // OUT: instruction: contains a list of instruction for the robot to move to the destination
146     if (GameParameters\&.getType(px, py) == GameParameters\&.AreaType\&.InStarting) {
147       GameUtil\&.startingFinder\&.tryFindPath(cur, destination, instruction);
148     } else {
149       GameUtil\&.searchingFinder\&.tryFindPath(cur, destination, instruction);
150     }
151 
152     // use the instruction modified by the pathFind to move to the destination
153     char lastStep = ' ';
154     int theta = 0;
155 
156     while (instruction\&.size() > 0) {
157       char step = instruction\&.remove(instruction\&.size() - 1);
158       // if the step is different from the last one, rotate to corresponding rotation
159       if (step != lastStep) {
160         theta = charToRotation(step);
161         turnTo(theta);
162       }
163 
164       // add a value to the robot traveled distance
165       if (step == GameUtil\&.leftInstruction) {
166         px--;
167       } else if (step == GameUtil\&.rightInstruction) {
168         px++;
169       } else if (step == GameUtil\&.upInstruction) {
170         py++;
171       } else {
172         py--;
173       }
174       lastStep = step;
175 
176       moveWithCorrection(1, theta);
177       // get the position of the robot
178       double[] position = odometer\&.getXYT();
179       if (Math\&.round(position[0]) == px && Math\&.round(position[1]) == py) {
180         // this means that the robot is at the point, so set the position to the point
181         odometer\&.setX(px);
182         odometer\&.setY(py);
183       } else {
184         // otherwise some problem might happened and we are not at the desired point, push the
185         // instruction back
186         instruction\&.add(step);
187         // reset the added value to last point
188         if (step == GameUtil\&.leftInstruction) {
189           px++;
190         } else if (step == GameUtil\&.rightInstruction) {
191           px--;
192         } else if (step == GameUtil\&.upInstruction) {
193           py--;
194         } else {
195           py++;
196         }
197       }
198     }
199   }
.fi
.SS "void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turn (int angle)"
Rotate the robot by certain angle
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle to rotate our robot to 
.RE
.PP

.PP
Definition at line 618 of file Navigation\&.java\&.
.PP
.nf
618                               {
619     leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), true);
620     rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, angle), false);
621   }
.fi
.SS "synchronized void ca\&.mcgill\&.ecse211\&.project\&.Navigation\&.turnTo (double angle)"
This method is where the logic for the odometer will run\&. Use the methods provided from the OdometerData class to implement the odometer\&.
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle we want our robot to turn to (in degrees) 
.br
\fIasync\fP whether return instantaneously 
.RE
.PP

.PP
Definition at line 355 of file Navigation\&.java\&.
.PP
.nf
355                                                 {
356     double dTheta;
357 
358     dTheta = angle - odometer\&.getXYT()[2];
359     if (dTheta < 0)
360       dTheta += 360;
361 
362     // TURN RIGHT
363     if (dTheta > 180) {
364       leftMotor\&.setSpeed(ROTATE_SPEED);
365       rightMotor\&.setSpeed(ROTATE_SPEED);
366       try {
367         Thread\&.sleep(100);
368       } catch (InterruptedException e) {
369         // TODO Auto-generated catch block
370         e\&.printStackTrace();
371       }
372       leftMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), true);
373       rightMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, 360 - dTheta), false);
374     }
375     // TURN LEFT
376     else {
377       leftMotor\&.setSpeed(ROTATE_SPEED);
378       rightMotor\&.setSpeed(ROTATE_SPEED);
379       try {
380         Thread\&.sleep(100);
381       } catch (InterruptedException e) {
382         // TODO Auto-generated catch block
383         e\&.printStackTrace();
384       }
385       leftMotor\&.rotate(convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), true);
386       rightMotor\&.rotate(-convertAngle(Game\&.WHEEL_RAD, Game\&.TRACK, dTheta), false);
387     }
388   }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for ECSE211 - Fall 2018 - Final Project from the source code\&.
